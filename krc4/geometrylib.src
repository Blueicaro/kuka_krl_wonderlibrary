&ACCESS RV
&PARAM EDITMASK = *
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
DEF geometrylib( )
   ; Author:      Davide Rosa
   ; e-mail:      dddomodossola@gmail.com
   ; repository:  https://github.com/skilledAutomation/kuka_krl_wonderlibrary

   ; DESCRIPTION:
   ; This library provides geometric data structures and funcions
   ;   For 2D primitives, the plane is X/Y
END

;to be tested
global DEFFCT STR_LINE2D LINE2D_FROM_2P(p1:IN, p2:IN)
   E6POS p1
   E6POS p2
   DECL STR_LINE2D line

   REAL d, e

   d = p2.y - p1.y
   e = p2.x - p1.x
   line.a = d
   line.b = -e
   line.c = (e * p1.y) - (d * p1.x);

   line = LINE2D_FROM_ABC(line.a, line.b, line.c)

ENDFCT

;to be tested
global DEFFCT STR_LINE2D LINE2D_FROM_ABC(a:IN, b:IN, c:IN)
   REAL a
   REAL b
   REAL c

   DECL STR_LINE2D line

   line.a = a
   line.b = b
   line.c = c

   ;explicit form
   if (line.b == 0) then
      line.m = 0
      line.q = 0
      
   else
      line.m = (-line.a) / line.b
      line.q = (-line.c) / line.b

   endif

ENDFCT

;to be tested
global DEFFCT REAL LINE2D_DIST_FROM_POINT(p:IN)
   E6POS p
   REAL denominator

   denominator = sqrt(a*a + b*b)

    ;questo non puo' verificarsi perché affinché ci sia una retta a e b non possono essere contemporaneamente nulli
   if (denominator == 0) then
      return 0
   endif

   return abs(a * p.x + b * p.y + c) / denominator;
}

;to be tested
global DEFFCT REAL LINE2D_Y_GIVEN_X(x:IN)
   REAL x
   ; ax + by + c = 0
   if (line.b == 0) then
      return 0
   endif

   return ((-line.a * x) - line.c) / line.b
ENDFCT

;to be tested
global DEFFCT REAL LINE2D_X_GIVEN_Y(x:IN)
   REAL y
   ; ax + by + c = 0
   if (line.a == 0) then
      return 0
   endif

   return ((-line.b * y) - line.c) / line.a
ENDFCT

;to be tested
;unsafe: add denominator check to prevent disision by 0
global DEFFCT E6POS LINE2D_INTERSECTION(line1, line2)
   DECL STR_LINE2D line1
   DECL STR_LINE2D line2
   E6POS intersection

   intersection.y = ((-line1.a * line2.c) + (line1.c * line2.a)) / ((-line2.a * line1.b) + (line1.a * line2.b));
   intersection.x = ((-line1.b * p.y) - line1.c) / line1.a;

   return intersection
ENDFCT

;calculate the plane given 3 points
global DEFFCT STR_PLANE PLANE_FROM_3p(p1:IN, p2:IN, p3:IN)
   DECL E6POS p1
   DECL E6POS p2
   DECL E6POS p3
   REAL a21, a22, a23, a31, a32, a33
   
   DECL STR_PLANE plane

   a21 = p2.x - p1.x;
   a22 = p2.y - p1.y;
   a23 = p2.z - p1.z;
   a31 = p3.x - p1.x;
   a32 = p3.y - p1.y;
   a33 = p3.z - p1.z;
   plane.a = a22 * a33 - a23 * a32;
   plane.b = a23 * a31 - a21 * a33;
   plane.c = a21 * a32 - a22 * a31;
   plane.d = -p1.x * a22 * a33 - p1.y * a23 * a31 - p1.z * a21 * a32 + p1.z * a22 * a31 + p1.y * a21 * a33 + p1.x * a23 * a32;
ENDFCT

;calculate x coordinate on a plane, given y and z values
global DEFFCT REAL PLANE_X_GivenYZ(plane:IN, y:IN, z:IN)
   DECL STR_PLANE plane
   REAL y
   REAL z
   REAL x

   x = 0.0;
   if NOT (plane.a == 0) then
      x = (-plane.b * y - plane.c * z - plane.d) / plane.a;
   endif
   return x
ENDFCT

;calculate y coordinate on a plane, given x and z values
global DEFFCT REAL PLANE_Y_GivenXZ(plane:IN, x:IN, z:IN)
   DECL STR_PLANE plane
   REAL z
   REAL x
   REAL y

   y = 0.0;
   if NOT (plane.b == 0) then
      y = (-plane.a * x - plane.c * z - plane.d) / plane.b;
   endif
   return y
ENDFCT

;calculate z coordinate on a plane, given x and y values
global DEFFCT REAL PLANE_Y_GivenXZ(plane:IN, x:IN, y:IN)
   DECL STR_PLANE plane
   REAL x
   REAL y
   REAL z

   z = 0.0;
   if NOT (plane.c == 0) then
      z = (-plane.a * x - plane.b * y - plane.d) / plane.c;
   endif
   return z
ENDFCT

;calculate the distance between a plane and a point
global DEFFCT REAL PLANE_DIST_TO_POINT(plane:IN, p:IN)
   DECL STR_PLANE plane
   DECL E6POS p
   return abs(p.x + p.y + p.z + plane.d) / sqrt((plane.a * plane.a) + (plane.b * plane.b) + (plane.c * plane.c))
ENDFCT


