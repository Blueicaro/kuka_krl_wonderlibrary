&ACCESS RV
&PARAM EDITMASK = *
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
DEF geometrylib( )
   ; Author:      Davide Rosa
   ; e-mail:      dddomodossola@gmail.com
   ; repository:  https://github.com/skilledAutomation/kuka_krl_wonderlibrary

   ; DESCRIPTION:
   ; This library provides geometric data structures and funcions
   ;   For 2D primitives, the plane is X/Y
END

;to be tested
global DEFFCT STR_LINE2D LINE2D_FROM_2P(p1:IN, p2:IN)
   E6POS p1
   E6POS p2
   DECL STR_LINE2D line

   REAL d, e

   d = p2.y - p1.y
   e = p2.x - p1.x
   line.a = d
   line.b = -e
   line.c = (e * p1.y) - (d * p1.x);

   line = LINE2D_FROM_ABC(line.a, line.b, line.c)

   return line
ENDFCT

;to be tested
global DEFFCT STR_LINE2D LINE2D_FROM_ABC(a:IN, b:IN, c:IN)
   REAL a
   REAL b
   REAL c

   DECL STR_LINE2D line

   line.a = a
   line.b = b
   line.c = c

   ;explicit form
   if (line.b == 0) then
      line.m = 0
      line.q = 0
      
   else
      line.m = (-line.a) / line.b
      line.q = (-line.c) / line.b

   endif

   return line
ENDFCT

;to be tested
global DEFFCT REAL LINE2D_DIST_FROM_POINT(line:IN, p:IN)
   DECL STR_LINE2D line
   E6POS p
   REAL denominator

   denominator = sqrt(line.a*line.a + line.b*line.b)

    ;questo non puo' verificarsi perchÃ© affinchÃ© ci sia una retta a e b non possono essere contemporaneamente nulli
   if (denominator == 0) then
      return 0
   endif

   return abs(line.a * p.x + line.b * p.y + line.c) / denominator;
ENDFCT

;to be tested
global DEFFCT REAL LINE2D_Y_GIVEN_X(line:IN, x:IN)
   DECL STR_LINE2D line
   REAL x
   ; ax + by + c = 0
   if (line.b == 0) then
      return 0
   endif

   return ((-line.a * x) - line.c) / line.b
ENDFCT

;to be tested
global DEFFCT REAL LINE2D_X_GIVEN_Y(line:IN, y:IN)
   DECL STR_LINE2D line
   REAL y
   ; ax + by + c = 0
   if (line.a == 0) then
      return 0
   endif

   return ((-line.b * y) - line.c) / line.a
ENDFCT

;to be tested
;unsafe: add denominator check to prevent disision by 0
global DEFFCT E6POS LINE2D_INTERSECTION(line1:IN, line2:IN)
   DECL STR_LINE2D line1
   DECL STR_LINE2D line2
   E6POS intersection

   intersection.y = ((-line1.a * line2.c) + (line1.c * line2.a)) / ((-line2.a * line1.b) + (line1.a * line2.b));
   intersection.x = ((-line1.b * intersection.y) - line1.c) / line1.a;

   return intersection
ENDFCT

;calculate the plane given 3 points
global DEFFCT STR_PLANE PLANE_FROM_3p(p1:IN, p2:IN, p3:IN)
   DECL E6POS p1
   DECL E6POS p2
   DECL E6POS p3
   REAL a21, a22, a23, a31, a32, a33
   
   DECL STR_PLANE plane

   a21 = p2.x - p1.x;
   a22 = p2.y - p1.y;
   a23 = p2.z - p1.z;
   a31 = p3.x - p1.x;
   a32 = p3.y - p1.y;
   a33 = p3.z - p1.z;
   plane.a = a22 * a33 - a23 * a32;
   plane.b = a23 * a31 - a21 * a33;
   plane.c = a21 * a32 - a22 * a31;
   plane.d = -p1.x * a22 * a33 - p1.y * a23 * a31 - p1.z * a21 * a32 + p1.z * a22 * a31 + p1.y * a21 * a33 + p1.x * a23 * a32;
   
   return plane
ENDFCT

;calculate x coordinate on a plane, given y and z values
global DEFFCT REAL PLANE_X_GivenYZ(plane:IN, y:IN, z:IN)
   DECL STR_PLANE plane
   REAL y
   REAL z
   REAL x

   x = 0.0;
   if NOT (plane.a == 0) then
      x = (-plane.b * y - plane.c * z - plane.d) / plane.a;
   endif
   return x
ENDFCT

;calculate y coordinate on a plane, given x and z values
global DEFFCT REAL PLANE_Y_GivenXZ(plane:IN, x:IN, z:IN)
   DECL STR_PLANE plane
   REAL z
   REAL x
   REAL y

   y = 0.0;
   if NOT (plane.b == 0) then
      y = (-plane.a * x - plane.c * z - plane.d) / plane.b;
   endif
   return y
ENDFCT

;calculate z coordinate on a plane, given x and y values
global DEFFCT REAL PLANE_Z_GivenXY(plane:IN, x:IN, y:IN)
   DECL STR_PLANE plane
   REAL x
   REAL y
   REAL z

   z = 0.0;
   if NOT (plane.c == 0) then
      z = (-plane.a * x - plane.b * y - plane.d) / plane.c;
   endif
   return z
ENDFCT

;calculate the distance between a plane and a point
global DEFFCT REAL PLANE_DIST_TO_POINT(plane:IN, p:IN)
   DECL STR_PLANE plane
   DECL E6POS p
   return abs(p.x + p.y + p.z + plane.d) / sqrt((plane.a * plane.a) + (plane.b * plane.b) + (plane.c * plane.c))
ENDFCT

global DEFFCT STR_LINE3D LINE3D_FROM_PLANES(plane1:IN, plane2:IN)
   DECL STR_PLANE plane1
   DECL STR_PLANE plane2
   DECL STR_LINE3D line3d

   line3d.plane1 = plane1
   line3d.plane2 = plane2

   line3d.point.x = 0
   line3d.point.y = +plane1.c * plane2.d / (plane1.b * plane2.c - plane1.c * plane2.b) - plane1.d * plane2.c / (plane1.b * plane2.c - plane1.c * plane2.b)
   line3d.point.z = -plane1.b * plane2.d / (plane1.b * plane2.c - plane1.c * plane2.b) + plane1.d * plane2.b / (plane1.b * plane2.c - plane1.c * plane2.b)

   line3d.vec.l = 1
   line3d.vec.m = (-plane1.a * plane2.c + plane1.c * plane2.a) / (plane1.b * plane2.c - plane1.c * plane2.b)
   line3d.vec.n = (plane1.a * plane2.b - plane1.b * plane2.a) / (plane1.b * plane2.c - plane1.c * plane2.b)

   return line3d
ENDFCT

global DEFFCT STR_LINE3D LINE3D_FROM_PARAMETRIC(point:IN, vec:IN)
   DECL E6POS point
   DECL STR_VECTOR3D vec
   DECL STR_LINE3D line3d

   INT count

   line3d.point = point
   line3d.vec = vec

   count = 0
   if (NOT (vec.l == 0)) then
      count = count + 1
   endif
   if (NOT (vec.m == 0)) then
      count = count + 1
   endif
   if (NOT (vec.n == 0)) then
      count = count + 1
   endif

   if (count == 3) then
      line3d.plane1.a = -(vec.m / vec.l)
      line3d.plane1.b = 1 
      line3d.plane1.c = 0
      line3d.plane1.d = point.x * vec.m / vec.l - point.y

      line3d.plane2.a = -(vec.n / vec.l)
      line3d.plane2.b = 0
      line3d.plane2.c = 1
      line3d.plane2.d = point.x * vec.n / vec.l - point.z
   endif

   if (count == 2) then
      if (vec.l == 0.0) then
         line3d.plane1.a = 1
         line3d.plane1.b = 0
         line3d.plane1.c = 0
         line3d.plane1.d = point.x
         line3d.plane2.a = 0
         line3d.plane2.b = -(vec.n / vec.m)
         line3d.plane2.c = 1
         line3d.plane2.d = (vec.n * point.y) / vec.m
      endif
     if (vec.m == 0.0) then
         line3d.plane1.a = 0
         line3d.plane1.b = 1
         line3d.plane1.c = 0
         line3d.plane1.d = point.y
         line3d.plane2.a = -(vec.n / vec.l)
         line3d.plane2.b = 0
         line3d.plane2.c = 1
         line3d.plane2.d = (vec.n * point.x) / vec.l
     endif
     if (vec.n == 0.0) then
         line3d.plane1.a = 0
         line3d.plane1.b = 0
         line3d.plane1.c = 1
         line3d.plane1.d = point.z
         line3d.plane2.a = -(vec.m / vec.l)
         line3d.plane2.b = 1
         line3d.plane2.c = 0
         line3d.plane2.d = (vec.m * point.x) / vec.l
     endif
   endif

   if (count == 1) then
      if (vec.l <> 0.0) then
         line3d.plane1.a = 0
         line3d.plane1.b = 1
         line3d.plane1.c = 0
         line3d.plane1.d = point.y
         line3d.plane2.a = 0
         line3d.plane2.b = 0
         line3d.plane2.c = 1
         line3d.plane2.d = point.z
      endif
      if (vec.m <> 0.0) then
         line3d.plane1.a = 1
         line3d.plane1.b = 0
         line3d.plane1.c = 0
         line3d.plane1.d = point.x
         line3d.plane2.a = 0
         line3d.plane2.b = 0
         line3d.plane2.c = 1
         line3d.plane2.d = point.z
      endif
      if (vec.n <> 0.0) then
         line3d.plane1.a = 1
         line3d.plane1.b = 0
         line3d.plane1.c = 0
         line3d.plane1.d = point.x
         line3d.plane1.a = 0
         line3d.plane1.b = 1
         line3d.plane1.c = 0
         line3d.plane1.d = point.y
      endif
   endif

   return line3d
ENDFCT

global DEFFCT E6POS LINE3D_POINT_FROM_ORIGIN(line3d:IN, distance:IN)
   DECL STR_LINE3D line3d
   DECL REAL distance
   DECL E6POS point

   
   point.x = line3d.point.x + distance * line3d.vec.l
   point.y = line3d.point.y + distance * line3d.vec.m
   point.z = line3d.point.z + distance * line3d.vec.n
   return point
ENDFCT

global DEFFCT STR_VECTOR3D VECTOR3D_DIRECTOR_COSINE(vec:IN)
   DECL STR_VECTOR3D vec
   DECL STR_VECTOR3D res
   
   res.l = vec.l / sqrt(vec.l * vec.l + vec.m * vec.m + vec.n * vec.n)
   res.m = vec.m / sqrt(vec.l * vec.l + vec.m * vec.m + vec.n * vec.n)
   res.n = vec.n / sqrt(vec.l * vec.l + vec.m * vec.m + vec.n * vec.n)
   return res
ENDFCT

;returns polar spherical coordinates of the 3d line. angles are expressed in degrees
global DEF LINE3D_TO_POLAR_COORD(line3d:IN, radius:OUT, polar_angle:OUT, azimut:OUT)
   DECL STR_LINE3D line3d
   DECL REAL radius
   DECL REAL polar_angle
   DECL REAL azimut
   ;float& r /*raggio*/, float& B /*angolo polare*/, float& C /*azimut*/)
   radius = sqrt((line3d.vec.l * line3d.vec.l) + (line3d.vec.m * line3d.vec.m) + (line3d.vec.n * line3d.vec.n))
   polar_angle = atan2(sqrt(line3d.vec.l * line3d.vec.l + line3d.vec.m * line3d.vec.m), line3d.vec.n) * 180.0 / M_PI
   azimut = atan2(line3d.vec.m, line3d.vec.l) * 180.0 / M_PI;
END

;this procedure calculate one coordinate given a line3d and the other two coordinates
global DEF LINE3D_yzGivenX(line3d:IN, x:IN, y:OUT, z:OUT)
   DECL STR_LINE3D line3d
   DECL REAL x
   DECL REAL y
   DECL REAL z
   z = 0.0
   if ((line3d.plane1.b <> 0) AND (line3d.plane2.c <> 0) AND ((1.0 - line3d.plane2.b * line3d.plane1.c * (1.0 / line3d.plane1.b) * (1.0 / line3d.plane2.c)) <> 0)) then
      z = (line3d.plane2.b * line3d.plane1.a * x * (1.0 / line3d.plane1.b) * (1.0 / line3d.plane2.c) + line3d.plane2.b * line3d.plane1.d * (1.0 / line3d.plane1.b) * (1.0 / line3d.plane2.c) - line3d.plane2.a * x * (1.0 / line3d.plane2.c) - line3d.plane2.d * (1.0 / line3d.plane2.c)) / (1.0 - line3d.plane2.b * line3d.plane1.c * (1.0 / line3d.plane1.b) * (1.0 / line3d.plane2.c))
   endif

   y = 0.0
   if (line3d.plane1.b <> 0.0) then
     y = (-line3d.plane1.c * z - line3d.plane1.a * x - line3d.plane1.d) / line3d.plane1.b;
   endif
END

;this procedure calculate one coordinate given a line3d and the other two coordinates
global DEF LINE3D_xzGivenY(line3d:IN, x:OUT, y:IN, z:OUT)
   DECL STR_LINE3D line3d
   DECL REAL x
   DECL REAL y
   DECL REAL z
   z = 0.0
   if ((line3d.plane1.a <> 0) AND (line3d.plane2.c <> 0) AND ((1.0 - line3d.plane2.a * line3d.plane1.c * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.c)) <> 0)) then
      z = (line3d.plane2.a * line3d.plane1.b * y * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.c) + line3d.plane2.a * line3d.plane1.d * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.c) - line3d.plane2.b * y * (1.0 / line3d.plane2.c) - line3d.plane2.d * (1.0 / line3d.plane2.c)) / (1.0 - line3d.plane2.a * line3d.plane1.c * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.c))
   endif

   x = 0.0
   if (line3d.plane1.a <> 0) then
      x = (-line3d.plane1.c * z - line3d.plane1.b * y - line3d.plane1.d) / line3d.plane1.a;
   endif
END

;this procedure calculate one coordinate given a line3d and the other two coordinates
global DEF LINE3D_xyGivenZ(line3d:IN, x:OUT, y:OUT, z:IN)
   DECL STR_LINE3D line3d
   DECL REAL x
   DECL REAL y
   DECL REAL z
   y = 0.0
   if ((line3d.plane1.a <> 0) AND (line3d.plane2.b <> 0) AND ((1.0 - line3d.plane2.a * line3d.plane1.b * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.b)) <> 0)) then
      y = (line3d.plane2.a * line3d.plane1.c * z * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.b) + line3d.plane2.a * line3d.plane1.d * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.b) - line3d.plane2.c * z * (1.0 / line3d.plane2.b) - line3d.plane2.d * (1.0 / line3d.plane2.b)) / (1.0 - line3d.plane2.a * line3d.plane1.b * (1.0 / line3d.plane1.a) * (1.0 / line3d.plane2.b))
   endif

   x = 0.0
   if (line3d.plane1.a <> 0) then
      x = (-line3d.plane1.b * y - line3d.plane1.c * z - line3d.plane1.d) / line3d.plane1.a;
   endif
END
